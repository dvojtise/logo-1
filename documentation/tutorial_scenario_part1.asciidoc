## Scenario tutorial day one

### Installation steps

* Install an Oracle Java JDK (minimum 8, max 10,  Oracle is preferred due to 
support of openFX used for tha day 2 tutorial)  
* grab and unzip the latest dev version of GEMOC Studio  http://download.eclipse.org/gemoc/packages/nightly/

### Basic xText

NOTE: Start the first Eclipse, we will call it the *Language Workbench*

* File -> new -> project -> xtext project
** project name: fr.inria.sed.logo.xtext
** Name: fr.inria.sed.logo.xtext.Logo
** Extensions: logo
* montrer la grammaire de base
* generate mwe2

Create a launch configuration that runs a new Eclipse similar to the current one  but also including the plugins under development in the workspace: 

* Run -> Run configurations... -> Right click on Eclipse Application -> new configutation

[NOTE]
====
 
Start the Second Eclipse,
we will call it the *Modeling workbench*
==== 

Create a  project with an example model:

** new -> project
** new -> file, use *.logo* as file extension.
** Observe the basic features of the editor: completion/outline/syntax error marker

NOTE: Switch back to the *Language Workbench*

* show model/generated/ecore as tree view
* create aird (warning as xtext delete the content of the "generated" folder , do not create the aird in it and prefer model or directly the root of the project
** right click on model -> create representation, -> Initialization from semantic resource -> select the Logo.ecore file
** select "Design" representation
** create Entities in class diagram
** populate with ecore content
** show ecore model as diagram

* improve grammar, let's play grammar first

[source,]
----
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

LogoProgram :
	{LogoProgram}
	instructions+=Instruction (  instructions+=Instruction)*  
	;

Instruction :
	Forward | Left | Right  ;

Forward:
	'forward' steps=EInt;

Left :
	{Left}
	'left' angle=EInt;

Right :
	{Right}
	'right' angle=EInt;
	
EInt returns ecore::EInt:
	'-'? INT;

----

add proc decl

[source,]
----
Instruction :
	Forward | Left | Right | ProcDeclaration ;

ProcDeclaration :
	{ProcDeclaration}
	'to'
	name=EString
	
		(  args+=Parameter)* 
		instructions+=Instruction (  instructions+=Instruction)*  
	'end';
	
Parameter returns Parameter:
	{Parameter}
	':'name=EString;
EString returns ecore::EString:
	STRING | ID;
----

add proc call, ie. reference to a proc decl

[source,]
----
Instruction :
	Forward | Left | Right | ProcDeclaration | ProcCall;
ProcCall :
	declaration=[ProcDeclaration|EString]
	'(' (actualArgs+=EInt)? ( "," actualArgs+=EInt)* ')' 
	;
----

NOTE: Switch to the *Modeling Workbench*
Observe the completion at work

NOTE: Switch back to the *Language Workbench*

* open the *LogoValidator.xtend* file
* add some checker
[source,java]
----
	@Check
	def checkPassedParameters(ProcCall procCall){
		if(procCall.actualArgs.size != procCall.declaration.args.size){
			warning('invalid number of argument, (expecting '+procCall.declaration.args.size+')',
				procCall,
				LogoPackage.Literals.PROC_CALL__ACTUAL_ARGS
			)
		}
	}
----


Add quickfix

add this line in the mwe2 file (ine the language section
[source]
----
	// quickfix API
			fragment = ui.quickfix.QuickfixProviderFragment2 {}
----

regenerate

in the project xxx.logo.xtext.ui
open new file *LogoQuickfixProvider.xtend* and add the following:
[source,java]
----
	@Fix(Diagnostic.LINKING_DIAGNOSTIC)
	def void fixMissingProcDecl(Issue issue,
								IssueResolutionAcceptor acceptor) {
		if (issue.message.contains("ProcDeclaration")) {
			createMissingProcDecl(issue, acceptor);
		}
	}
	
	private def createMissingProcDecl(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue,
			"Create missing procedure declaration",
			"Create a new empty procedure declaration at the beginning of the file",
			null, // no icon 
			[ element, context |
				val root = element.getContainerOfType(typeof(LogoProgram))				
				root.instructions.add(
					0,
					LogoFactory::eINSTANCE.createProcDeclaration() => [
						name = context.xtextDocument.get(issue.offset,
						issue.length)
					]
				)
			]
		);
	}
----

When testing you can observe that there is no line break.

Additionnaly, if you do a right click -> source -> format, everything goes on single line.

Let's provide some autoformat informations: (see https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#formatting )

add in the mwe2 file:
[source]
----
language = StandardLanguage {
			...
			// formatter API 
			fragment = formatting.Formatter2Fragment2 {}
}
----
launch mwe2 generate.

open and fill the newly created *xxx.logo.xtext.formatting2.LogoFormatter.xtend* file.
[source,java]
----

----




show open with -> Sample Reflective Ecore editor

explain the tree view + property view

Points à faire attention/pièges:
containment du ecore resultant




add expression

TODO: vérifier l'utilisation de - dan les valeurs xtext




NOTE pour MM first vs grammar first
* permet de mieux controler les arbres d'héritage
* car difficulté de "regrouper" les attributs dans les classes parentes
(UnaryExpression, binaryExpression, contriol Structure


projet de test: grammaire

rapide et utile pour la non regression


autres truc cool à tester éventuellement sur certains languages: https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html

* rename refactoring https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#refactoring
* project and file wizard https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#projectwizard
* code mining https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#code-mining
* hyperlinking
* outline view and label provider (but it might be more productive to do it on the edit plugin when using model first approach
* content assist
* template proposal
* advanced syntax coloring (lexical and semantic)
*

support for qualified name, add in the mwe2 :
[source]
----
language = StandardLanguage {
			...
			qualifiedNamesProvider = {}
}
----

support for outline labels, add in the mwe2 :
[source]
----
language = StandardLanguage {
			...
			labelProvider = {
				generateStub = true
			}
}
----
then customize the stub

