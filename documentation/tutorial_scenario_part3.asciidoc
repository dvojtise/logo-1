== Scenario tutorial day two: Part 3: Hands-on GEMOC, the logo turtle language


This document indicates the steps to follow in order to reproduce the tutorial.

== Prerequisite

This part follows the work done in part2. 
While you can start from your own work, I suggest to replace it and start from the solution of part2.

so the starting projects are available in the folder _part2-mmfirst-solution_.

The solution of this tutorial is available in the folder _part3-mmfirst-solution_.



== General principles

We'll create an execution semantic for the behavior or our Logo language.

It will provide features such as:

* debugger
* animation 

[NOTE]
====
In order to keep the tutorial as simple as possible, we consider that we can modify the 
metamodel directly. this is correct for most languages you create by your own, but in some situation 
you may prefer to keep a stricter separation between the static and dynamic parts of the language. 
GEMOC offers several strategies to achieve this but they are out of the scope of this tutorial.
====
 






Principes généraux:
** MM first
**	trick pour éviter Melange et simplifier le tuto
	ajout d'un object abstrait "RuntimeContext" pour faciliter l'ancrage des concepts du RTD
	et possiblement la création de plusieurs sémantique différentes




== Define the dynamic semantic

=== Create a GEMOC Sequential project 

* _File -> New -> GEMOC Sequential XDSML Project_
** name: fr.inria.sed.logo.xdsml
* _Next_
** use the default template: Simple Sequential K3 language project
** Ecore file location: select the ecore file in _fr.inria.sed.logo.model/model/Logo.ecore_
* _Finish_


=== Create the project for domain specific action (DSA):

* right click on the _fr.inria.sed.logo.xdsml_ project -> GEMOC Language -> create
DSA project for language 
* _next_
** Select template: _User Ecore Basic Aspects_
* _next_
** Aspect package prefix: fr.inria.sed.logo.k3dsa
** Aspect package suffix: .aspects
** Aspect file name: LogoAspects
* _Finish_

* add missing dependency from project _fr.inria.sed.logo.xdsml_ to _fr.inria.sed.logo.k3dsa_. 
_(This action can be removed when https://github.com/eclipse/gemoc-studio-modeldebugging/issues/51[modeldebugging bug #51] is fixed)_. 


=== Write a GEMOC based method to "hello world"

In the k3dsa project, 

add a plugin dependency to `org.eclipse.gemoc.commons.eclipse.messagingsystem.api`

open the logoAspects.xtend file.

add the following imports:
[source,java]
----
import fr.inria.diverse.k3.al.annotationprocessor.Main
----

Add a _run_ method with *@Main* annotation in the class LogoProgramAspect.

[source,java]
----
	@Main
	def void run(){
		// println('hello world')
		val MessagingSystemManager msManager = new MessagingSystemManager
		val ms = msManager.createBestPlatformMessagingSystem("Logo","Simple Logo interpreter")
 		
		ms.debug("Hello world on "+_self.eResource.URI, "Logo")
	}
---- 

Launch the Modeling workbench.

* _Run -> Debug configurations..._
** Right click on _Gemoc Sequential eXecutable Model_ -> _new configuration_
*** Name: <your model file name>
***  model to execute: browse and select the model file
*** Languages: _fr.inria.sed.logo.Logo
*** animator: (optionnal) the .aird file that has a diagram for your model
*** Main method: select xxx.LogoProgramAspect.run(xxx)
*** Main model element path: the LogoProgramImpl
** _Debug_

The console named "Simple Logo interpreter" will contain your output if you used the GEMOC MessagingSystem, 
otherwise, `printl` will go to the standard output which is shown by the _Default MessagingSystem console_.

NOTE: you may have to switch between the console in order to retrieve the one with your message.




=== Define Runtime Data structure

* _new Ecore Modeling Project_ 
** project name: _fr.inria.sed.logo.vm.model_
** Main package name: vm
** NsUris: ``http://www.inria.fr/sed/logo/vm``

[TIP]
====
Installing OCLinEcore allows to write the ecore model in text instead of using the three editor or the graphica editor.
In our case, this will help to to copy/paste actions.

* _Help -> Install new software..._
** Work with: _Eclipse Repository - http://download.eclipse.org/releases/photon_
** get: _OCL Examples and Editors SDK_
** proceed to the installation and accept to restart eclipse

A new editor is now available with a right click on `ecore` files: _Open with -> OCLInEcore Editor_. 
====


==== Create a data structure to capture the runtime state of the turtle running the logo program.

The runtime will be turtle that also store the path it had drawn. 

The path is stored as an ordered list of segments.

Some attributes need to be encoded as Double in order to get a simple but realistic simulation. 

image::images/vm_ecore_sirius.png[,500] 

[TIP]
====
Instead of manually creating the various elements in the tree or Sirius editor you can directly 
use this source and copy/paste using oclinecore editor.

[source,]
----
import ecore : 'http://www.eclipse.org/emf/2002/Ecore' ;

package logo_vm : logo_vm = 'http://fr.inria.sed/logo/logo_vm'
{
	class Turtle
	{
		property reachedPoints : Point[*|1] { ordered composes };
		property position : Point[?];
		property segments : Segment[*|1] { ordered composes };
		attribute penUp : Boolean[1];
		attribute heading : ecore::EDouble[1];
	}
	class Point
	{
		attribute x : ecore::EDouble[1];
		attribute y : ecore::EDouble[1];
	}
	class Segment
	{
		property origin : Point[1];
		property destination : Point[1];
	}
}
----

====

* right click on the vm.genmodel file -> reload...
* rigth click on the root element
* generate Model code


on the plugin.xml of the k3dsa project, add a dependency to _fr.inria.sed.logo.vm.model_.

Create a link from  




TODO main pur java

TODO main GEMOC


ajout method @main sur logoProgram et eval qui "traverse/evalue" le programme 

[source,]
----
@Aspect(className=LogoProgram)
class LogoProgramAspect {
	@Step 												
	@InitializeModel									
	def void initializeModel(EList<String> args){
	
	}
	
	@Main
	def void main() {
		println("Starting Logo program")
		_self.eval()
		println("Logo program ended")
	}
	def void eval(){		
		println("Evaluating "+_self)
		_self.instructions.forEach[i | i.eval]
	}
}

@Aspect(className=Instruction)
class InstructionAspect {
	def void eval(){
		println("Evaluating "+_self)
	}
}
----

mettre au point la semantique

ajout du @Step

ajout d'un context / runtime data


trick par ajout d'un attribut Context à LogoProgram

[source,]
----
LogoProgram :
	{LogoProgram}
	instructions+=Instruction (  instructions+=Instruction)* 
	(runtimecontext = RuntimeContext)? 
	;

RuntimeContext returns RuntimeContext:
	{RuntimeContext}
	'RuntimeContext'
;
----


discussion à propos du model first pou masquer cet aspect de la syntaxe

ajout d'un projet ecore modeling "fr.inria.sed.logo.vm.model"

ajout des concepts

heritage de InterpreterContext vers RuntimeContext


puis convertir en 2 languages avec melange : extended pour activer la timeline ou adapter le MM




